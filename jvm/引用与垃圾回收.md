---
title: jvm 引用与垃圾回收
date: 2020-07-07 18:56:22
tags: Jvm
categories: Jvm
---

回顾一下 Linux 操作系统的内存管理， 我们所说的电脑装机硬件内存指的是 “物理内存”， 物理内存的划分是按照内存页分块的。一般 linux 系统的内存页是 4096 k。 但是我们说的给 JVM 分配的内存， 是“逻辑内存”，即此内存看起来连续，看起来占用了操作系统的全部内存其实只是部分物理内存页的映射。 在没有使用全部逻辑内存的时候，操作系统是不会分配全量的物理内存， 只有在committed 之后才分配对应物理内存，并且物理内存也不是连续的。

所以，JVM 的内存是看似独立的、连续的虚拟地址空间。

那么，不连续会造成什么问题？ 如果对于需要连续内存的数据结构，一旦内存碎片化严重，其大对象将无法放入内存。如，很占用空间的数组对象。

由于，linux 系统的 swap backing store，可以申请超越物理内存的内存空间（linux 不认为所有程序同时内存占用满载， 可以交换一部分到对应的硬盘）。

内存分配的基本单元是进程。所以我们分析引用与垃圾回收，把内存空间视为连续的。（其实是虚拟内存）


## 一、 复习 JVM 内存结构

JVM 内存主要分为 五个部分， 其中 程序计数器、 方法栈 、 本地方法栈 是线程私有。其他文章分享过， 这里只是简单回顾。

### 1、程序计数器

程序计数器，主要用于 cpu 在线程之间切换时候记录指令位置。只占用很少一点空间， 不会发生 gc， 也没有 OOM。

### 2、方法栈

方法栈，线程执行的方法会依次压栈， 如果递归深度过深 容易发生 stackOverFlow  异常。 方法会以栈帧的形式压栈， 最先 Main() 或者 Thread.run() 。

### 3、本地方法栈

本地方法栈，专门用来存放对本地方法的引用， 因为 Native 本地方法底层是对 c 或 c++ 方法的调用， 所以不能以栈帧结构存储，调用本地方法指向本地方法栈再指向本地方法。（底层好像是个 hashtable）


### 4、堆 Heap

堆，基本是所有对象在内存中的存储空间。new 出来的对象都在堆中存储。垃圾回收重灾区， 本文会重点介绍堆的划分与 GC 过程。 


### 5、方法区

这部分最乱， 主要因为总乱改名，存储东西也发生改变 。可是 jvm 虚拟机规范中对这部分说的又特别少。  逻辑上方法区在堆中， 但却不进行正常的垃圾回收， 所以也叫非堆。java 7 以前这部分中有个永久代，用来存放类的信息，还是存在堆内！1.8 以后永久代也移除了，变成了元空间，已经转移到了 Heap 外 ！

堆外转移主要是由于 动态创建 class 的情况变多了， 影响堆空间和垃圾回收。

所以，这仨东西区别？ jvm 规范这部分叫 “方法区”！而 1.7 实现成了 “永久代”， 1.8 实现成了 “元空间”。

所以方法区存什么？  Class 的元数据 ， （运行时常量池， 字段，方法数据） 。


## 二、 heap 的划分

### 1、 新生代

(百分之八十的对象 朝生夕死，剩下的对象生命周期非常长 。 所以搞了一个分代回收算法 。 )

1.1 eden 伊甸园

对象刚创建出来(new)，会被直接放进伊甸园区。 除非对象过大，先进行一遍ygc，如果young区地方够大就放进去，否则直接丢进老年代。（追踪一下后续，old 区如果还放不下对象就会进行 fullgc ， 如果还放不下就 OOM）


>heap 分区比例：
eden:s0:s1 = 8:1:1
young:old = 1:2

1.2 s0 幸存者0

1.3 s1 幸存者1

注 ： 幸存者区也叫 from 和 to 区 ， 不过 From 和 to 总是来回变化的。

>命令 ： 
>设置 jvm 堆空间的大小 `最大 heap 内存 ： -Xmx  初始heap内存 ：-Xms`


### 2、老年代




### 3、永久代




## 三、常见垃圾回收算法


GC 算法总分三种： 标记清除 、 标记清除压缩 、 标记复制

>垃圾收集器 ： 
Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；


https://www.cnblogs.com/cxxjohnson/p/8625713.html

### 0、概述

先说一下 GC 划分，这种划分是根据 GC 区域的划分。 

Minor GC ： 只回收 young 新生代 

Major GC ： 只回收 old 老年代 （只有 CMS）

Mixed GC ： 新生代 +  部分老年代 （只有 G1）

Full GC ： 新生代 + 老年代


### 1、G1 中的算法

G1 创新 ， 分块分代 ！ 把 heap 默认分成了 1024 个块， 举例来说 young 可以不连续。



### 2、CMS 中

老年代使用标记清除。但是由串行 GC 升级到了 并行 GC。


### 3、引用计数

已经没什么使用场景了。 对象 a 有一个 count 记录了 " 谁引用了a "。b 引用 a， a.count + 1, 取消引用 count - 1。 为 0 被垃圾回收。 

优点， 快！ 缺点解决不了循环引用。


### 4、jvm GC-Roots 与 可达性分析


篇幅比较长， 将在《jvm GC-Roots 与 可达性分析》中详细介绍。


串行算法： 弄一个线程工作在不同的分代，把用户线程停掉。年轻代 ， 复制算法；老年代 ， 标记整理。
并行算法： 同上，只不过是并发线程，用户线程和垃圾线程一起工作。

CMS ： 并发的标记清除，不能回收年轻代数据。没法进行内存整理，长生碎片。

G1 ： 设置 stw 时间， 而且进行分片


## 四、GC 调优


1、STW （最关键指标）


目标就是减少延迟。（扫描完全部对象的时间）


所以，并不是堆越大，STW 时间就越短。


2、Safe Point

给所有对象设置安全点， GC 可以开始扫描 GC-Root， 开始标记。

3、heap 并非越大越好

