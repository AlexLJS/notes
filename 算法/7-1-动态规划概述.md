---
title: 7-1  动态规划概述
date: 2020-09-14 08:18:55
tags: 动态规划
categories: Algorithm
---

今天9月14日，下午有两场笔试，用今天把DP总结一下。

## 一、概述

### 1、经典DP题目

>背包问题、跳台阶、最长回文子串、字符串子序列、字符串子串、扔鸡蛋...

为何经典面试、笔试题目都是DP？ 因为DP代码量小，却能反映很多的思维过程。

DP问题的本质 ： 从一个局部出发推出整体的全貌，这个局部就是高中学过的“递推公式”。DP问题本质是要用空间换时间，这个空间就是常见的 DP 表。

### 2、动态规划

>先提一个暴论：我非常不喜欢写出“暴力递归  =>  动态规划”，当然这个暴力递归可以是回溯+剪枝， 但是对于不是科班的我来说无疑增加了时间成本、思维过程，并且很难有效改成 DP。 


概念：将一个复杂的过程分解成若干个子问题，但是子问题不是相互独立（有别于分治法），动态规划中试图保存子问题的解，后续问题如果能用到这个子问题的解，直接查找表单，节省时间。

动态规划常常基于一个递推公式或一个或多个初始状态。找到某一个状态的最优解，在他的帮助下找到下一状态的最优解。解释状态的含义、列状态转移方程变得尤为重要。（某些贪心问题也是dp问题的特例）

接下来会举一个题目，举 ACwing 的 “闫氏DP分析法”， 我觉得此法比较高效。

## 二、DP 题目举例

入门题：(也没那么入门)

### 题目1：有面值为1元、2元和5元的硬币若干枚，凑够n元有多少方案？

思路：
我们把 1、2、5 的面值组合给推广开， v[i] 数组。

状态表示：dp[i][j] 表示前i种硬币， 凑够j元一共有多少方案
状态转移：dp[i][j] = （求和）dp[i-1][j - m*v[i]] (m从 0 ~ j/v[i] ) 

解释： 求三种硬币满足价值 j 的组合数，等于求 1枚第3种硬币 + 前两种硬币的组合数满足价值 j - 1 * v[3] , 2枚第三种硬币 + 前两种硬币的组合数满足价值 j - 2 * v[3] …… 
完成了状态转移。代码如下 ：   

```
    public int coins(int n , int[] v){
        if (v.length == 0) return n == 0? 1: 0;
        Arrays.sort(v);

        int[][] dp = new int[v.length][n+1];
        //初始化
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            dp[0][i] = i>=v[0] && i%v[0] == 0? 1: 0;
        }
        for (int i = 1; i < v.length; i++) {
            dp[i][0] = 1;
        }
        //状态转移
        for (int i = 1; i < dp.length; i++){
            for (int j = 1; j <= n; j++) {
                for (int k = 0; k <= j/v[i]; k++) {
                    dp[i][j] += dp[i - 1][j - k * v[i]];
                }
            }
        }
        //PrintUtil.printMatrix(dp);
        return  dp[v.length - 1][n];
    }

```
当然，这是最朴素的解法。我们发现这个状态依赖是只依赖 i - 1 行的 。最直观的方式， 利用滚动数组是肯定可以优化到一维 ， 后续会详谈DP优化问题。PS 这也是一道完全背包问题。

参考 LC 518 零钱兑换 2 ， 官方解法。
```
class Solution {
  public int change(int amount, int[] coins) {
    int[] dp = new int[amount + 1];
    dp[0] = 1;

    for (int coin : coins) {
      for (int x = coin; x < amount + 1; ++x) {
        dp[x] += dp[x - coin];
      }
    }
    return dp[amount];
  }
}

```


### 题目2：有面值为1元、2元和5元的硬币若干枚，凑够n元最少的硬币数是多少？

思路：
本题思路可以相对简单一些， 类似于跳台阶问题。 dp[i] 表示最少需要多少硬币，那么dp[i] 必定来自于 dp[i - v[1]] 、 dp[i - v[2]] ...dp[i - v[k]] 的最小值，再加上最后一枚硬币 得来的（+ 1）。 

参考一下官解 技巧性非常强的代码：

```
public class MinCoins {
    public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
        int[] dp = new int[amount + 1];
        // 填充初始值， 即规避掉单独初始化 dp[i] （dp[i] 初始为 0 无法比最小值）
        // 又可以通过最值规避无解情况。 功力深厚，望尘莫及
        Arrays.fill(dp, max);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}

```

## 三、DP 题目解法

ACwing 的 “闫氏DP分析法” ， 虽然此法好用， 我觉得解 DP 的大部分思路是依靠经验！甚至把思路记下来， 比实际操作更重要。 “闫氏DP分析法” 的核心在于将状态理解为集合。 


### 第一部分 ： 状态表示

#### 1、集合

比如我们常用的二维 DP ， dp[i][j] ，表示一种结果集。常说的“含义”，就是形成这个结果集的条件。

例如： 01 背包问题

集合： dp[i][j] 表示满足“条件”所有选法的集合。
条件： ① 选 0-i （前i）个物品 ② 总体积 <= j

至于，dp[i][j] 存的东西，就是集合中的最大值！（即属性）

#### 2、属性

常用的属性分为三种 ： Max 、Min、 数量


### 第二部分 ： 状态计算

这部分就是常说的 “状态转移方程”。

状态计算对应的是 集合的划分，“热狗法”。我们要思考的是 ：

> 如何把已知集合划分成 更小的可以求解的子集？

原则：不重（不漏）。（不重复更重要一点）

最经典的划分 ： 两个部分- “要 i” 和 “不要 i”。

例如 ： 01 背包问题

`dp[i][j]= max(dp[i-1][j], dp[i-1][j - v[i]] + w[i])` 