volatile 是 java 中最轻量的同步机制， 初识一下 volatile  关键字。

## 同步简述

同步： 控制不同线程之间操作发生的相对顺序。

java 中线程操作共享内存，也称为主存。 但是，由于 cpu 运行过快与内存速率不对等，所以 cpu 一般操作其内部的缓存（l1、l2、l3）。这样产生同步问题，我们可以把这种不对等抽象成 JMM 模型（略）， 即把线程缓存抽象成线程工作内存。

##  volatile  作用 

volatile  作用概括讲，只有两个：

>1）禁止指令重排

>2）共享内存数据立刻同步主存

## 原理 

禁止指令重排序通过使用 memory barries 内存屏障，（ cpu 层面的一组处理器指令，限制对内存的操作顺序） 。

对 volatile 变量进行写操作时，通过反编译发现底层使用了 LOCK 关键字。此关键字执行了以下两个操作：

> 将处理器缓存立刻写回主存

> 使得其他 cpu 缓存对于这条记录的缓存失效

注：其中第二点的实现，需要通过现代处理器 cpu 层面的缓存一致性协议来实现。并且只是对单行记录做失效处理，cache line （缓存行）。 在目前主流处理器中 cache line 都是 64 个字节， 这里引发一个问题，如果缓存行失效，原有失效的缓存没有填满整行，导致本行的其他缓存失效。  
 

## 初识 happens - before 

happens - before 是 java 内存模型用来描述操作之间的内存可见性的概念， 可以简单的理解为 java 代码在 jvm 中的执行顺序。（实际上， happens - before 描述的是操作之间结果的可见性，实际操作是可能违反happens - before 的先后顺序）

> 先行发生的8大原则：程序次序原则、监视器锁定原则、volatile原则、线程启动原则、线程终止原则、线程中断原则、对象终结原则、传递性原则 。

实际上对于 java 开发人员只关注其中几项，并且， 日常开发中潜意识已经默认原则的存在：

1、程序顺序规则
先写的代码先于后写的代码执行。

注意 ： happens - before 保证结果的可见性，实际上指令可以被编译器、cpu在不同层面上进行重排序， 执行乱序但保证最终结果一致。

2、监视器锁规则
指的是，解锁操作一定发生在上锁操作之后。 （监视器锁指synchronized）

3、volatile原则
对于一个 volatile 关键字，写操作发生在后续任意读操作之前。（准确讲，写操作 happens - before 于这个时间节点之后的任意的读操作之前， 即写操作在读过程中也对读操作可见。）

4、传递性原则
a  happens - before b ， b happens - before c ， 则 a happens - before c。


----
## 补充

volatile 经典应用， 就是被用于 写 DCL 单例模式， 在单例模式中有所介绍。

另一经典面试题 ： 
volatile 保证可见性，能保证原子性吗？ 
网络上普遍答案，不能保证原子性，例如 常用的 ++ 操作。实际上，volatile 对于单个变量的读写是具有原子性的，只是对于 ++ 这种复合操作不能保证原子性，  显然操作不是原子的（保证原子性还是要上锁）。 


（本文提取自 《java 并发编程艺术》， 这本书真的好，会对所有点进行展开）
